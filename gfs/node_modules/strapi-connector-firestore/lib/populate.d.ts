import type { Transaction } from './db/transaction';
import type { Reference, Snapshot } from './db/reference';
import { FirestoreConnectorModel } from './model';
/**
 * Defines a type where all Reference members of T are populated as their referred types (including arrays of references).
 * Note: This typing is not accurate for components, where all references would be populated, but this type does not populate
 * any keys inside components.
 */
export declare type Populated<T extends object> = {
    [Key in keyof T]: T[Key] extends Reference<infer R> ? R : T[Key] extends Reference<infer R>[] ? R[] : T[Key];
};
/**
 * Picks the keys of T whose values are References or arrays of references.
 */
export declare type PickReferenceKeys<T extends object> = Extract<{
    [Key in keyof T]-?: T[Key] extends Reference<infer R> ? Key : T[Key] extends Reference<infer R>[] ? Key : never;
}[keyof T], string>;
/**
 * Defines a type where all Reference members amongst those with the given keys are populated as their referred types.
 * Note: This typing is not accurate for components, where all references would be populated, but this type does not populate
 * any keys inside components.
 */
export declare type PopulatedByKeys<T extends object, K extends PickReferenceKeys<T>> = Omit<T, K> & Populated<Pick<T, K>>;
/**
 * Populates all the requested relational field on the given documents.
 */
export declare function populateSnapshots<T extends object, K extends PickReferenceKeys<T>>(snaps: Snapshot<T>[], populate: K[], transaction: Transaction): Promise<PopulatedByKeys<T, K>[]>;
/**
 * Populates all the requested relational field on the given document.
 * All references in components are populated by default.
 */
export declare function populateDoc<T extends object, K extends PickReferenceKeys<T>>(model: FirestoreConnectorModel<T>, ref: Reference<T>, data: T, populateKeys: K[], transaction: Transaction): Promise<PopulatedByKeys<T, K>>;
