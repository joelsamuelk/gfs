import type { FirestoreConnectorModel } from '../model';
import type { Transaction } from '../db/transaction';
import { Reference } from '../db/reference';
export interface RelationInfo<T extends object> {
    model: FirestoreConnectorModel<T>;
    attr: RelationAttrInfo | undefined;
    parentModels: RelationInfo<any>[] | undefined;
}
export interface RelationAttrInfo {
    alias: string;
    isArray: boolean;
    filter: string | undefined;
    isMorph: boolean;
    /**
     * Indicates that this is a "virtual" attribute
     * which is metadata/index map for a repeatable component,
     * or a deep path to a non-repeatable component,
     * and the actual alias inside the component is this value.
     */
    actualAlias: {
        componentAlias: string;
        parentAlias: string;
    } | undefined;
    /**
     * Indicates that this is a metadata/index map, not a path to
     * an actual attribute.
     */
    isMeta: boolean;
}
export declare class RelationHandler<T extends object, R extends object = object> {
    private readonly thisEnd;
    private readonly otherEnds;
    constructor(thisEnd: RelationInfo<T>, otherEnds: RelationInfo<R>[]);
    /**
     * Gets the alias of this relation, or `undefined`
     * if this end of the relation is not dominant.
     */
    get alias(): string | undefined;
    /**
     * Finds references to the related models on the given object.
     * The related models are not necessarily fetched.
     */
    findRelated(ref: Reference<T>, data: T, transaction: Transaction): Promise<Reference<R>[]>;
    /**
     * Updates the the related models on the given object.
     */
    update(ref: Reference<T>, prevData: T | undefined, newData: T | undefined, editMode: 'create' | 'update', transaction: Transaction): Promise<void>;
    /**
     * Populates the related models onto the given object for this relation.
     */
    populateRelated(ref: Reference<T>, data: T, transaction: Transaction): Promise<void>;
    private get _singleOtherEnd();
    /**
     * Creates an appropriate `ReferenceShape` to store in the documents
     * at the other end, properly handling polymorphic references.
     *
     * @param ref The reference to this
     * @param otherAttr Attribute info of the other end (which refers to this)
     */
    private _makeRefToThis;
    /**
     * Checks the `Reference` to store in this document,
     * properly handling polymorphic references.
     *
     * @param otherRef The reference to the other end
     */
    private _makeRefToOther;
    private _setThis;
    private _setAllRelated;
    private _setRelated;
    private _queryRelated;
    private _getRefInfo;
    private _getSingleRefInfo;
}
