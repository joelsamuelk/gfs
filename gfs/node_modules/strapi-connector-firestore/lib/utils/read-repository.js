"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadRepository = void 0;
const _ = require("lodash");
const firestore_1 = require("@google-cloud/firestore");
/**
 * Utility class for transactions that acts as a caching proxy for read operations.
 */
class ReadRepository {
    constructor(handler, delegate) {
        this.handler = handler;
        this.delegate = delegate;
        this.readCounter = 0;
        this.cache = new Map();
    }
    get size() {
        return this.cache.size;
    }
    get readCount() {
        return this.readCounter;
    }
    /**
     * Gets the given documents, first from this repository's cache, then
     * from the delegate repository's cache, or finally from the database.
     * Documents fetched from the database are stored in the cache.
     *
     * If field masks are provided, then results can be fulfilled from non-masked
     * cache entries, but masked requests from the database will not be stored in the cache.
     */
    async getAll(items) {
        const toRead = [];
        const results = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            const { ref, fieldMasks } = items[i];
            let result = this.cache.get(ref.path)
                || (this.delegate && this.delegate.cache.get(ref.path));
            if (!result) {
                // Create a new read operation grouped by field masks
                result = new Promise((resolve, reject) => {
                    const op = { ref, resolve, reject };
                    for (const entry of toRead) {
                        if (isFieldPathsEqual(entry.fieldMasks, fieldMasks)) {
                            entry.ops.push(op);
                            return;
                        }
                    }
                    toRead.push({
                        fieldMasks,
                        ops: [op],
                    });
                });
                // Only cache the new read operation if there is no field mask
                if (!fieldMasks) {
                    this.cache.set(ref.path, result);
                }
            }
            results[i] = result;
        }
        // Fetch and resolve all of the newly required read operations
        await Promise.all(toRead.map(ops => fetchGroupedReadOp(ops, this.handler)));
        this.readCounter += toRead.length;
        return Promise.all(results);
    }
    async getQuery(query) {
        const result = await this.handler.getQuery(query);
        for (const d of result.docs) {
            const { path } = d.ref;
            if (!this.cache.has(path)) {
                this.cache.set(path, Promise.resolve(d));
            }
        }
        this.readCounter += (result.docs.length || 1);
        return result;
    }
}
exports.ReadRepository = ReadRepository;
async function fetchGroupedReadOp({ fieldMasks, ops }, handler) {
    try {
        const snaps = await handler.getAll(ops.map(({ ref }) => ref), fieldMasks);
        let i = ops.length;
        while (i--) {
            ops[i].resolve(snaps[i]);
        }
    }
    catch (err) {
        for (const { reject } of ops) {
            reject(err);
        }
    }
}
function isFieldPathsEqual(a, b) {
    return _.isEqualWith(a, b, (aVal, bVal) => {
        if (aVal instanceof firestore_1.FieldPath) {
            return aVal.isEqual(bVal);
        }
        return undefined;
    });
}
