"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const _ = require("lodash");
const firestore_1 = require("@google-cloud/firestore");
const model_1 = require("./model");
const queries_1 = require("./queries");
const flat_collection_1 = require("./db/flat-collection");
const defaults = {
    defaultConnection: 'default',
};
const defaultOptions = {
    useEmulator: false,
    singleId: 'default',
    flattenModels: [],
    allowNonNativeQueries: false,
    ensureComponentIds: true,
    logTransactionStats: process.env.NODE_ENV === 'development',
    logQueries: false,
    metadataField: '$meta',
    creatorUserModel: { model: 'user', plugin: 'admin' },
    beforeMountModel: () => { },
    afterMountModel: () => { },
    // Default to 200 because of query size used in admin permissions query
    // https://github.com/strapi/strapi/blob/be4d5556936cf923aa3e23d5da82a6c60a5a42bc/packages/strapi-admin/services/permission.js
    maxQuerySize: 200,
};
module.exports = (strapi) => {
    // Patch BigInt to allow JSON serialization
    if (!BigInt.prototype.toJSON) {
        BigInt.prototype.toJSON = function () { return this.toString(); };
    }
    // Patch Firestore types to allow JSON serialization
    firestore_1.DocumentReference.prototype.toJSON = function () { return this.id; };
    firestore_1.Timestamp.prototype.toJSON = function () { return this.toDate().toJSON(); };
    firestore_1.FieldPath.prototype.toJSON = function () { return this.toString(); };
    const { connections } = strapi.config;
    const firestoreConnections = Object.keys(connections)
        .filter(connectionName => {
        const connection = connections[connectionName];
        if (connection.connector !== 'firestore') {
            strapi.log.warn('You are using the Firestore connector alongside ' +
                'other connector types. The Firestore connector is not ' +
                'designed for this, so you will likely run into problems.');
            return false;
        }
        else {
            return true;
        }
    });
    const initialize = async () => {
        await Promise.all(firestoreConnections.map(async (connectionName) => {
            const connection = connections[connectionName];
            _.defaults(connection.settings, strapi.config.hook.settings.firestore);
            const options = _.defaults(connection.options, defaultOptions);
            const settings = {
                ignoreUndefinedProperties: true,
                useBigInt: true,
                ...connection.settings,
            };
            if (options.useEmulator) {
                // Direct the Firestore instance to connect to a local emulator
                Object.assign(settings, {
                    port: 8080,
                    host: 'localhost',
                    sslCreds: require('@grpc/grpc-js').credentials.createInsecure(),
                    customHeaders: {
                        "Authorization": "Bearer owner"
                    },
                });
            }
            const firestore = new firestore_1.Firestore(settings);
            _.set(strapi, `connections.${connectionName}`, firestore);
            const initFunctionPath = path.resolve(strapi.config.appPath, 'config', 'functions', 'firebase.js');
            if (await fs.pathExists(initFunctionPath)) {
                require(initFunctionPath)(firestore, connection);
            }
            // Mount all models
            await (0, model_1.mountModels)({
                strapi,
                firestore,
                connectorOptions: options,
            });
            // TODO: Find a way to initialise the connection lazily, and avoid performing a write operation on
            // every startup, because read operations are cheaper.
            // Initialise all flat collections
            // We do it here rather than lazily, otherwise the write which
            // ensures the existence will contend with the transaction that
            // operates on the document
            // In the Firestore production server this resolves and retries
            // but in the emulator it results in deadlock
            const tasks = [];
            for (const { model: { db } } of (0, model_1.allModels)()) {
                if (db instanceof flat_collection_1.FlatCollection) {
                    tasks.push(db.ensureDocument());
                }
            }
            await Promise.all(tasks);
        }));
    };
    const destroy = async () => {
        await Promise.all(firestoreConnections.map(async (connectionName) => {
            const firestore = strapi.connections[connectionName];
            if (firestore instanceof firestore_1.Firestore) {
                await firestore.terminate();
            }
        }));
    };
    return {
        defaults,
        initialize,
        destroy,
        queries: queries_1.queries,
        defaultTimestamps: [model_1.DEFAULT_CREATE_TIME_KEY, model_1.DEFAULT_UPDATE_TIME_KEY],
    };
};
