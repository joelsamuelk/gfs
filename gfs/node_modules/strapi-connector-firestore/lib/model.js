"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mountModels = exports.allModels = exports.eachModel = exports.DEFAULT_UPDATE_TIME_KEY = exports.DEFAULT_CREATE_TIME_KEY = void 0;
const _ = require("lodash");
const utils = require("strapi-utils");
const normal_collection_1 = require("./db/normal-collection");
const flat_collection_1 = require("./db/flat-collection");
const component_collection_1 = require("./db/component-collection");
const populate_1 = require("./populate");
const prefix_query_1 = require("./utils/prefix-query");
const firestore_1 = require("@google-cloud/firestore");
const relations_1 = require("./relations");
const components_1 = require("./utils/components");
const components_indexing_1 = require("./utils/components-indexing");
const status_error_1 = require("./utils/status-error");
const transaction_runner_1 = require("./utils/transaction-runner");
const virtual_collection_1 = require("./db/virtual-collection");
exports.DEFAULT_CREATE_TIME_KEY = 'createdAt';
exports.DEFAULT_UPDATE_TIME_KEY = 'updatedAt';
const { PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE, } = utils.contentTypes.constants;
/**
 * Iterates each model in a the given of models.
 */
function* eachModel(models) {
    for (const key of Object.keys(models)) {
        const model = models[key];
        yield { model, target: models, key };
    }
}
exports.eachModel = eachModel;
/**
 * Iterates all models in the Strapi instance.
 * @param strapiInstance Defaults to global Strapi
 */
function* allModels(strapiInstance = strapi) {
    // Iterate components first because subsequent models 
    // need to access the indexers
    yield* eachModel(strapiInstance.components);
    yield* eachModel(strapiInstance.models);
    yield* eachModel(strapiInstance.admin.models);
    for (const plugin of Object.keys(strapi.plugins)) {
        yield* eachModel(strapiInstance.plugins[plugin].models);
    }
}
exports.allModels = allModels;
/**
 * Mounts the Firestore model implementation onto the existing instance of all Strapi models.
 * They are mounted onto the existing instance because that instance is already
 * propagated through many parts of Strapi's core.
 */
async function mountModels(args) {
    // Call the before mount hook for each model
    // then mount initialise all models onto the existing model instances
    const modelPromises = [];
    for (const { model, target, key } of allModels(args.strapi)) {
        modelPromises.push(Promise.resolve()
            .then(() => args.connectorOptions.beforeMountModel(model))
            .then(() => mountModel(target, key, model, args)));
    }
    const models = await Promise.all(modelPromises);
    // Build relations
    for (const model of models) {
        (0, relations_1.buildRelations)(model, args.strapi);
    }
    // Call the after mount hook for each model
    await Promise.all(models.map(model => args.connectorOptions.afterMountModel(model)));
}
exports.mountModels = mountModels;
function mountModel(target, modelKey, mdl, { strapi, firestore, connectorOptions }) {
    var _a, _b, _c;
    mdl.orm = 'firestore';
    mdl.primaryKey = mdl.primaryKey || 'id';
    mdl.primaryKeyType = mdl.primaryKeyType || 'string';
    mdl.attributes = mdl.attributes || {};
    mdl.collectionName = mdl.collectionName || mdl.globalId;
    const isComponent = mdl.modelType === 'component';
    const opts = mdl.options || {};
    const flattening = defaultFlattenOpts(mdl, opts, connectorOptions);
    mdl.collectionName = (flattening === null || flattening === void 0 ? void 0 : flattening.collectionName) || mdl.collectionName;
    const options = {
        ...opts,
        populateCreatorFields: opts.populateCreatorFields || false,
        timestamps: opts.timestamps || false,
        logQueries: (_a = opts.logQueries) !== null && _a !== void 0 ? _a : connectorOptions.logQueries,
        singleId: (flattening === null || flattening === void 0 ? void 0 : flattening.singleId) || opts.singleId || connectorOptions.singleId,
        flatten: flattening != null,
        searchAttribute: defaultSearchAttrOpts(mdl, opts),
        maxQuerySize: flattening ? 0 : (_b = opts.maxQuerySize) !== null && _b !== void 0 ? _b : connectorOptions.maxQuerySize,
        ensureComponentIds: (_c = opts.ensureComponentIds) !== null && _c !== void 0 ? _c : connectorOptions.ensureComponentIds,
        allowNonNativeQueries: defaultAllowNonNativeQueries(mdl, opts, connectorOptions),
        metadataField: opts.metadataField || connectorOptions.metadataField,
        creatorUserModel: opts.creatorUserModel || connectorOptions.creatorUserModel,
        converter: opts.converter || {},
        virtualDataSource: opts.virtualDataSource || null,
        onChange: opts.onChange || (() => { }),
    };
    const timestamps = (options.timestamps && (typeof options.timestamps === 'boolean'))
        ? [exports.DEFAULT_CREATE_TIME_KEY, exports.DEFAULT_UPDATE_TIME_KEY]
        : options.timestamps;
    options.timestamps = timestamps;
    // Make sure any primary key attribute has the correct type
    // Normally this doesn't exist, but it may exist if the user has
    // used it to customise indexing of components
    if (mdl.attributes[mdl.primaryKey]) {
        const attr = mdl.attributes[mdl.primaryKey];
        attr.type = mdl.primaryKeyType;
    }
    if (!mdl.uid.startsWith('strapi::') && mdl.modelType !== 'component') {
        if (utils.contentTypes.hasDraftAndPublish(mdl)) {
            mdl.attributes[PUBLISHED_AT_ATTRIBUTE] = {
                type: 'datetime',
                configurable: false,
                writable: true,
                visible: false,
            };
        }
        const isPrivate = options.populateCreatorFields;
        const creatorModelAttr = typeof options.creatorUserModel === 'string'
            ? { model: options.creatorUserModel }
            : options.creatorUserModel;
        mdl.attributes[CREATED_BY_ATTRIBUTE] = {
            configurable: false,
            writable: false,
            visible: false,
            private: isPrivate,
            ...creatorModelAttr,
        };
        mdl.attributes[UPDATED_BY_ATTRIBUTE] = {
            configurable: false,
            writable: false,
            visible: false,
            private: isPrivate,
            ...creatorModelAttr,
        };
    }
    const componentKeys = Object.keys(mdl.attributes)
        .filter(key => {
        const { type } = mdl.attributes[key];
        return type && ['component', 'dynamiczone'].includes(type);
    });
    // Build indexers if this is a component model
    const indexers = (0, components_indexing_1.buildIndexers)(mdl);
    // Add all component's metadata keys as attributes on this model
    const getMetadataMapKey = typeof options.metadataField === 'string'
        ? (attrKey) => attrKey + options.metadataField
        : options.metadataField;
    Object.assign(mdl.attributes, buildMetadataAttributes(mdl, { componentKeys, getMetadataMapKey }));
    // Metadata attributes are configured as private and will
    // automatically be populated in the private attributes list
    const privateAttributes = utils.contentTypes.getPrivateAttributes(mdl);
    const assocKeys = Object.keys(mdl.attributes)
        .filter(alias => {
        const { model, collection } = mdl.attributes[alias];
        return model || collection;
    });
    const defaultPopulate = assocKeys
        .filter(alias => {
        var _a;
        const attr = mdl.attributes[alias];
        return (_a = attr.autoPopulate) !== null && _a !== void 0 ? _a : true;
    });
    for (const attrKey of Object.keys(mdl.attributes)) {
        // Required for other parts of Strapi to work
        utils.models.defineAssociations(mdl.uid.toLowerCase(), mdl, mdl.attributes[attrKey], attrKey);
    }
    const hasPK = (obj) => {
        return _.has(obj, mdl.primaryKey) || _.has(obj, 'id');
    };
    const getPK = (obj) => {
        return ((_.has(obj, mdl.primaryKey) ? obj[mdl.primaryKey] : obj.id));
    };
    const populate = async (snap, transaction, populate = defaultPopulate) => {
        const data = snap.data();
        if (!data) {
            throw new status_error_1.StatusError('entry.notFound', 404);
        }
        return await (0, populate_1.populateDoc)(model, snap.ref, data, populate || model.defaultPopulate, transaction);
    };
    const populateAll = async (snaps, transaction, populate = defaultPopulate) => {
        return await (0, populate_1.populateSnapshots)(snaps, populate, transaction);
    };
    const query = (init) => {
        let field;
        let value;
        let operator;
        const qb = {
            where: (f, op, v) => {
                operator = op;
                field = f;
                value = v;
            }
        };
        init(qb);
        if ((operator !== 'like') || !/^\w+%$/.test(value)) {
            throw new Error('An update to Strapi has broken `strapi-connector-firestore`. '
                + 'Please create an issue at https://github.com/arrowheadapps/strapi-connector-firestore/issues, '
                + 'or in the meantime, revert Strapi your version to the last working version.');
        }
        // Remove '%' character from the end
        value = value.slice(0, -1);
        return {
            fetchAll: async () => {
                const { gte, lt } = (0, prefix_query_1.buildPrefixQuery)(value);
                const results = await strapi.query(modelKey).find({
                    [`${field}_gte`]: gte,
                    [`${field}_lt`]: lt,
                });
                return {
                    toJSON: () => results
                };
            }
        };
    };
    const getAttributePath = (fieldOrPath) => {
        let path;
        if (fieldOrPath instanceof firestore_1.FieldPath) {
            if (firestore_1.FieldPath.documentId().isEqual(fieldOrPath)) {
                return model.primaryKey;
            }
            path = fieldOrPath.toString();
        }
        else {
            path = fieldOrPath;
        }
        if (path.endsWith('.id')) {
            // Special case:
            // We could encounter field path that refers to the "id" field of a reference
            // In this case we return the path to the reference itself, and the query value
            // should be coerced to a reference also for comparison
            const refPath = path.slice(0, -3);
            const attr = model.attributes[refPath];
            if (attr && (attr.model || attr.collection)) {
                path = refPath;
            }
        }
        return path;
    };
    const getAttribute = (fieldOrPath) => {
        const path = getAttributePath(fieldOrPath);
        if (path === model.primaryKey) {
            return { type: 'string' };
        }
        else {
            return model.attributes[path];
        }
    };
    const getAttributeValue = (fieldOrPath, snapshot) => {
        const path = getAttributePath(fieldOrPath);
        if (path === model.primaryKey) {
            return snapshot.id;
        }
        return _.get(snapshot.data(), path, undefined);
    };
    const model = Object.assign({}, mdl, {
        firestore,
        options,
        timestamps,
        relations: [],
        isComponent,
        privateAttributes,
        assocKeys,
        componentKeys,
        defaultPopulate,
        indexers,
        getMetadataMapKey,
        getAttributePath,
        getAttribute,
        getAttributeValue,
        // We assign this next
        // The constructors need these other values to be populated onto the model first
        db: null,
        hasPK,
        getPK,
        runTransaction: (0, transaction_runner_1.makeTransactionRunner)(firestore, options, connectorOptions),
        populate,
        populateAll,
        /**
         * HACK:
         * For `strapi-plugin-content-manager` which accesses the raw
         * ORM layer and only knows about mongoose and bookshelf connectors.
         * See: https://github.com/strapi/strapi/blob/535fa25311a2caa469a13d173d710a7eba6d5ecc/packages/strapi-plugin-content-manager/services/utils/store.js#L52-L68
         *
         * It seems that the aim here is to emulate searching for
         * a prefix in the `key` field.
         *
         * ```
         * return model
         *  .query(qb => {
         *    qb.where('key', 'like', `${key}%`);
         *  })
         *  .fetchAll()
         *  .then(config => config && config.toJSON())
         *  .then(results => results.map(({ value }) => JSON.parse(value)));
         * ```
         */
        query,
    });
    model.db = isComponent
        ? new component_collection_1.ComponentCollection(model)
        : opts.virtualDataSource
            ? new virtual_collection_1.VirtualCollection(model)
            : flattening
                ? new flat_collection_1.FlatCollection(model)
                : new normal_collection_1.NormalCollection(model);
    // Mimic built-in connectors
    // They re-assign an (almost) identical copy of the model object
    // Without this, there is an infinite recursion loop in the `privateAttributes`
    // property getter
    target[modelKey] = model;
    Object.assign(mdl, _.omit(model, ['privateAttributes']));
    return model;
}
function defaultAllowNonNativeQueries(model, options, connectorOptions) {
    if (options.allowNonNativeQueries === undefined) {
        const rootAllow = connectorOptions.allowNonNativeQueries;
        if (typeof rootAllow === 'boolean') {
            return rootAllow;
        }
        const tests = _.castArray(rootAllow)
            .map(test => {
            if (typeof test === 'function') {
                return test;
            }
            const regex = test instanceof RegExp ? test : new RegExp(test);
            const tester = (model) => regex.test(model.uid);
            return tester;
        })
            .map(tester => {
            return tester(model);
        });
        return tests.some(t => t);
    }
    else {
        return options.allowNonNativeQueries;
    }
}
function defaultFlattenOpts(model, options, connectorOptions) {
    const singleId = options.singleId || connectorOptions.singleId;
    const result = {
        collectionName: null,
        singleId,
    };
    if (options.flatten === undefined) {
        const { flattenModels } = connectorOptions;
        if (typeof flattenModels === 'boolean') {
            return flattenModels ? result : null;
        }
        const tests = _.castArray(flattenModels)
            .map(test => {
            let testFn;
            if (typeof test === 'function') {
                testFn = test;
            }
            else {
                const regex = test instanceof RegExp ? test : new RegExp(test);
                testFn = (model) => regex.test(model.uid) ? singleId : null;
            }
            const flatten = testFn(model);
            if (!flatten) {
                return null;
            }
            if (flatten instanceof firestore_1.DocumentReference) {
                return flatten.path;
            }
            return (typeof flatten === 'string') ? flatten : singleId;
        });
        const path = tests.find(test => test != null);
        if (path) {
            const i = path.lastIndexOf('/');
            return {
                collectionName: (i === -1) ? null : path.slice(0, i),
                singleId: (i === -1) ? path : path.slice(i + 1),
            };
        }
        return null;
    }
    else {
        return options.flatten ? result : null;
    }
}
function defaultSearchAttrOpts(model, options) {
    var _a;
    const searchAttr = options.searchAttribute || '';
    if (searchAttr) {
        const type = (searchAttr === model.primaryKey)
            ? 'uid'
            : (_a = model.attributes[searchAttr]) === null || _a === void 0 ? void 0 : _a.type;
        const notAllowed = [
            'password',
            'dynamiczone',
            'component',
        ];
        if (!type || notAllowed.includes(type)) {
            throw new Error(`The search attribute "${searchAttr}" does not exist on the model ${model.uid} or is of an unsupported type.`);
        }
    }
    return searchAttr;
}
/**
 * Build attributes for the metadata map fields.
 */
function buildMetadataAttributes(model, { componentKeys, getMetadataMapKey }) {
    const attributes = {};
    if (model.modelType !== 'component') {
        for (const alias of componentKeys) {
            const attr = model.attributes[alias];
            if (!(0, components_indexing_1.doesComponentRequireMetadata)(attr)) {
                continue;
            }
            const mapKey = getMetadataMapKey(alias);
            if (mapKey in model.attributes) {
                throw new Error(`The metadata field "${mapKey}" in model "${model.uid}" conflicts with an existing attribute.`);
            }
            const models = attr.component ? [attr.component] : (attr.components || []);
            for (const modelName of models) {
                // We rely on component models being mounted first
                const { indexers } = (0, components_1.getComponentModel)(modelName);
                for (const info of indexers) {
                    for (const key of Object.keys(info.indexers)) {
                        const attrPath = `${mapKey}.${key}`;
                        // Other Strapi internals would get confused by the presence of fields if the value is undefined
                        const attrValue = _.omitBy({
                            collection: info.attr.model || info.attr.collection,
                            via: info.attr.via,
                            type: info.attr.type,
                            plugin: info.attr.plugin,
                            isMeta: true,
                            repeatable: true,
                            private: true,
                            configurable: false,
                            writable: false,
                            visible: false,
                        }, value => value === undefined);
                        const existingAttrValue = attributes[attrPath];
                        if (existingAttrValue) {
                            if (existingAttrValue.collection
                                && attrValue.collection
                                && (existingAttrValue.collection !== attrValue.collection)) {
                                // Consider different collections as polymorphic
                                existingAttrValue.collection = attrValue.collection = '*';
                            }
                            // Make sure all overlapping indexed attribute in dynamic-zone components are compatible
                            // Required so that we know how to coerce the metadata map back and forth from Firestore
                            if (!_.isEqual(attributes[attrPath], attrValue)) {
                                throw new Error(`The indexed attribute "${info.alias}" of component "${modelName}" is not compatible with an indexed attribute of another component. ` +
                                    `The parent attribute is "${alias}" in model "${model.uid}"`);
                            }
                        }
                        attributes[attrPath] = attrValue;
                        // Add the empty indicator meta attribute
                        // This is so that we can query for "empty" without relying on inequality operators, which imposes more restrictions on sorting etc
                        attributes[`${attrPath}$empty`] = {
                            type: 'boolean',
                            isMeta: true,
                            repeatable: true,
                            private: true,
                            configurable: false,
                            writable: false,
                            visible: false,
                        };
                        // Set layout config on the model so that the attribute is hidden
                        _.set(model, ['config', 'attributes', attrPath], { hidden: true });
                    }
                }
            }
        }
    }
    return attributes;
}
