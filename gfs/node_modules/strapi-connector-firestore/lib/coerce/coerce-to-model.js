"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coerceAttrToModel = exports.coerceToModel = exports.CoercionError = void 0;
const _ = require("lodash");
const parseType = require("strapi-utils/lib/parse-type");
const firestore_1 = require("@google-cloud/firestore");
const reference_1 = require("../db/reference");
const status_error_1 = require("../utils/status-error");
const components_1 = require("../utils/components");
const morph_reference_1 = require("../db/morph-reference");
const components_indexing_1 = require("../utils/components-indexing");
const field_operation_1 = require("../db/field-operation");
class CoercionError extends status_error_1.StatusError {
    constructor(message) {
        super(message, 400);
    }
}
exports.CoercionError = CoercionError;
/**
 * Attempts to coerce the data to the correct types based on the
 * given model schema, builds `Reference` instances for relations, and generates
 * index metadata for components.
 *
 * Designed to both coerce from user input, or rehydrate from Firestore.
 */
function coerceToModel(model, id, data, fieldPath, opts) {
    const obj = coerceModelRecursive(model, data, fieldPath, opts);
    // If fieldPath is provided then this is a partial update map
    // and this is not the root object
    if (!fieldPath) {
        // Set the document ID
        if (id) {
            _.set(obj, model.primaryKey, id);
        }
        // Assign timestamps
        if (model.timestamps && opts.editMode) {
            const now = opts.timestamp || new Date();
            const [createdAtKey, updatedAtKey] = model.timestamps;
            _.set(obj, updatedAtKey, now);
            if (opts.editMode === 'create') {
                _.set(obj, createdAtKey, now);
            }
            else {
                _.unset(obj, createdAtKey);
            }
        }
        // Generate metadata only for edits (to Firestore)
        if (opts.editMode) {
            (0, components_indexing_1.updateComponentsMetadata)(model, obj);
        }
    }
    return obj;
}
exports.coerceToModel = coerceToModel;
function fallbackCoerceOrCopy(value, opts) {
    const result = coerceAttrToModel(undefined, value, opts);
    if (result === value) {
        // If coercion returned the same object then we return undefined
        // to that cloneDeepWith handles the copying
        // We need this in order to copy root object etc
        return undefined;
    }
    return result;
}
function coerceModelRecursive(model, data, parentPath, opts) {
    return _.cloneDeepWith(data, (value, key) => {
        const path = [parentPath, key].filter(Boolean).join('.');
        if (!path) {
            // Root object, pass through
            // Perform basic coercion
            // E.g. this handles document-level FieldOperation.delete()
            // for flattened collections
            return fallbackCoerceOrCopy(value, opts);
        }
        const attr = model.attributes[path];
        if (!attr && _.isPlainObject(value)) {
            if (key) {
                return coerceModelRecursive(model, value, path, opts);
            }
            else {
                // Stop infinite recursion
                // Perform basic coercion of necessary types
                return fallbackCoerceOrCopy(value, opts);
            }
        }
        return coerceAttrToModel(attr, value, opts);
    });
}
/**
 * Coerces a given attribute value to out of the value stored in Firestore to the
 * value expected by the given attribute schema.
 */
function coerceAttrToModel(attr, value, opts) {
    var _a;
    if (Array.isArray(value) && (attr === null || attr === void 0 ? void 0 : attr.isMeta)) {
        // Meta attributes are arrays, so we need to coerce the value recursively
        return value.map(v => coerceAttrToModel(attr, v, opts));
    }
    // Coerce values inside FieldOperation
    if (value instanceof field_operation_1.FieldOperation) {
        return value.coerceWith(v => coerceAttrToModel(attr, v, opts));
    }
    // Cannot operate on FieldValue
    if (value instanceof firestore_1.FieldValue) {
        strapi.log.warn('Cannot coerce instances of FieldValue, which may result in incorrect data types being ' +
            'written to Firestore. Recommend to use FieldOperation equivalent instead.');
        return value;
    }
    // Firestore returns Timestamp for all Date values
    if (value instanceof firestore_1.Timestamp) {
        return value.toDate();
    }
    // Restore number fields back
    // Because Firestore returns BigInt for all integer values
    // Do this by default for all BigInt unless the attribute is specifically a BigInt
    // BigInt fields will come out as native BigInt but will be serialised to JSON as a string
    if ((typeof value === 'bigint') && (!attr || (attr.type !== 'biginteger'))) {
        return Number(value);
    }
    // Don't coerce unknown fields further
    if (!attr) {
        return value;
    }
    // Allow null or undefined on any type
    if ((value === null) || (value === undefined)) {
        return value;
    }
    // Recursively coerce components
    // type == 'component'
    if (attr.component) {
        const componentModel = (0, components_1.getComponentModel)(attr.component);
        if (Array.isArray(value)) {
            // Generate ID if setting dictates
            return value.map(v => coerceToModel(componentModel, getIdOrAuto(componentModel, v), v, null, opts));
        }
        else {
            if (value) {
                if (typeof value !== 'object') {
                    return fault(opts, 'Invalid value provided. Component must be an array or an object.');
                }
                // Generate ID if setting dictates
                return coerceToModel(componentModel, getIdOrAuto(componentModel, value), value, null, opts);
            }
            else {
                return null;
            }
        }
    }
    // Recursively coerce dynamiczone
    // type == 'dynamiczone'
    if (attr.components) {
        if (Array.isArray(value)) {
            return value.map(v => {
                // Generate ID if setting dictates
                const componentModel = (0, components_1.getComponentModel)(v.__component);
                return coerceToModel(componentModel, getIdOrAuto(componentModel, v), v, null, opts);
            });
        }
        else {
            if (value) {
                if (typeof value !== 'object') {
                    return fault(opts, 'Invalid value provided. Component must be an array or an object.');
                }
                // Generate ID if setting dictates
                const componentModel = (0, components_1.getComponentModel)(value.__component);
                return coerceToModel(componentModel, getIdOrAuto(componentModel, value), value, null, opts);
            }
            else {
                return null;
            }
        }
    }
    if (attr.type) {
        const v = value;
        const err = () => fault(opts, `Invalid value provided. Could not coerce to type "${attr.type}" from value "${v}".`);
        switch (attr.type) {
            case 'integer':
            case 'float':
            case 'decimal':
                if (typeof value !== 'number') {
                    value = Number(value);
                    if (Number.isNaN(value)) {
                        return err();
                    }
                }
                break;
            case 'biginteger':
                if (typeof value !== 'bigint') {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        return err();
                    }
                }
                break;
            case 'string':
            case 'text':
            case 'richtext':
            case 'email':
            case 'password':
            case 'enumeration':
            case 'uid':
                if (typeof value !== 'string') {
                    value = (_a = value) === null || _a === void 0 ? void 0 : _a.toString();
                }
                break;
            case 'json':
                try {
                    value = ((typeof value === 'string') && value.startsWith('{'))
                        ? JSON.parse(value)
                        : value;
                }
                catch {
                    return err();
                }
                break;
            case 'boolean':
            case 'date':
            case 'time':
            case 'datetime':
            case 'timestamp':
            default:
                // These types can be handled by built-in Strapi utils
                value = parseType({ type: attr.type, value });
                break;
        }
    }
    else {
        // Convert reference ID to document reference if it is one
        const target = attr.model || attr.collection;
        if (target) {
            const assocModel = strapi.db.getModel(target, attr.plugin);
            if (assocModel) {
                // Convert DeepReference instances to a string value
                // that can be serialised to Firestore
                if (Array.isArray(value)) {
                    value = value.map(v => {
                        return coerceToReference(v, assocModel, opts);
                    });
                }
                else {
                    return coerceToReference(value, assocModel, opts);
                }
            }
        }
    }
    // References will come out as references unchanged
    // but will be serialised to JSON as path string value
    // Strings will come out as strings unchanged
    // Arrays will come out as arrays
    return value;
}
exports.coerceAttrToModel = coerceAttrToModel;
/**
 * Coerces a value to a `Reference` if it is one.
 */
function coerceToReference(value, to, opts) {
    if ((value === undefined) || (value === null)) {
        return null;
    }
    if (value instanceof reference_1.Reference) {
        return value;
    }
    if (value instanceof firestore_1.DocumentReference) {
        // When deserialised from Firestore it comes without any converters
        // We want to get the appropriate converters so we reinstantiate it
        return reinstantiateReference(value, undefined, to, opts);
    }
    if ((typeof value === 'object')
        && ('ref' in value)
        && (value.ref instanceof firestore_1.DocumentReference)) {
        // Coerce from ReferenceShape
        // i.e. the Firestore representation of DeepReference and MorphReference
        const obj = value;
        let id;
        if ('id' in obj) {
            if (!obj.id || (typeof obj.id !== 'string')) {
                return fault(opts, 'Malformed polymorphic reference: `id` must be a string');
            }
            id = obj.id;
        }
        const ref = reinstantiateReference(obj.ref, id, to, opts);
        if (!ref) {
            return ref;
        }
        if ('filter' in obj) {
            if ((obj.filter !== null) && (!obj.filter || (typeof obj.filter !== 'string'))) {
                return fault(opts, 'Malformed polymorphic reference: `filter` must be a string');
            }
            return new morph_reference_1.MorphReference(ref, obj.filter);
        }
        else {
            return ref;
        }
    }
    if (typeof value === 'object') {
        // Coerce from the incoming Strapi API representation of
        // morph references
        // This isn't really documented
        const { ref: targetModelName, source: plugin, refId: id, field, } = value;
        if ((typeof targetModelName === 'string')
            && (typeof id === 'string')
            && (!plugin || (typeof plugin === 'string'))
            && (!field || (typeof field === 'string'))) {
            const targetModel = strapi.db.getModel(targetModelName, plugin);
            if (!targetModel) {
                return fault(opts, `The model "${targetModelName}" with plugin "${plugin}" in polymorphic relation could not be found`);
            }
            return new morph_reference_1.MorphReference(targetModel.db.doc(id), field);
        }
    }
    const path = (typeof value === 'string')
        ? value
        : (to ? to.getPK(value) : value.id);
    if (path && (typeof path === 'string')) {
        const lastSep = path.lastIndexOf('/');
        if (lastSep === -1) {
            // No path separators so it is just an ID
            if (to) {
                return to.db.doc(path);
            }
            else {
                return fault(opts, `Polymorphic reference must be fully qualified. Got the ID segment only.`);
            }
        }
        // TODO:
        // Remove this string parsing behaviour before stable release
        // DeepReference is no longer serialised to string
        // this is for alpha support only
        // It must be an absolute deep reference path
        // Verify that the path actually refers to the target model
        const id = path.slice(lastSep + 1);
        if (id) {
            if (to) {
                const deepRef = to.db.doc(id);
                if (deepRef.path !== _.trim(path, '/')) {
                    return fault(opts, `Reference is pointing to the wrong model. Expected "${deepRef.path}", got "${id}".`);
                }
                return deepRef;
            }
            else {
                const collection = _.trim(path.slice(0, lastSep), '/');
                const model = strapi.db.getModelByCollectionName(collection);
                if (!model) {
                    return fault(opts, `The model referred to by "${collection}" doesn't exist`);
                }
                return model.db.doc(id);
            }
        }
    }
    return fault(opts, `Value could not be coerced to a reference: "${JSON.stringify(value)}"`);
}
/**
 * When deserialised from Firestore, references comes without any converters.
 * Re-instantiates the reference via the target model so that it comes
 * loaded with the appropriate converter.
 */
function reinstantiateReference(value, id, to, opts) {
    if (to) {
        const newRef = to.db.doc(id || value.id);
        if (newRef.parent.path !== value.parent.path) {
            return fault(opts, `Reference is pointing to the wrong model. Expected "${newRef.path}", got "${value.path}".`);
        }
        return newRef;
    }
    else {
        const model = strapi.db.getModelByCollectionName(value.parent.path);
        if (!model) {
            return fault(opts, `The model referred to by "${value.parent.path}" doesn't exist`);
        }
        return model.db.doc(value.id);
    }
}
function getIdOrAuto(model, value) {
    if (model.options.ensureComponentIds) {
        // Ensure there is a guaranteed ID
        return _.get(value, model.primaryKey) || model.db.autoId();
    }
    else {
        // Don't delete it if it already exists
        return _.get(value, model.primaryKey);
    }
}
function fault({ editMode }, message) {
    if (editMode) {
        throw new CoercionError(message);
    }
    else {
        strapi.log.warn(message);
        return null;
    }
}
