"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateDoc = exports.populateSnapshots = void 0;
const _ = require("lodash");
const components_1 = require("./utils/components");
const status_error_1 = require("./utils/status-error");
/**
 * Populates all the requested relational field on the given documents.
 */
async function populateSnapshots(snaps, populate, transaction) {
    return await Promise.all(snaps.map(async (snap) => {
        const data = snap.data();
        if (!data) {
            throw new status_error_1.StatusError('entry.notFound', 404);
        }
        return await populateDoc(snap.ref.parent.model, snap.ref, data, populate, transaction);
    }));
}
exports.populateSnapshots = populateSnapshots;
/**
 * Populates all the requested relational field on the given document.
 * All references in components are populated by default.
 */
async function populateDoc(model, ref, data, populateKeys, transaction) {
    const promises = [];
    // Shallow copy the object
    const newData = Object.assign({}, data);
    // Populate own relations
    for (const key of populateKeys) {
        const relation = model.relations.find(r => r.alias === key);
        if (relation) {
            promises.push(relation.populateRelated(ref, newData, transaction));
        }
    }
    // Recursively populate components
    promises.push(...model.componentKeys.map(async (componentKey) => {
        const component = _.get(newData, componentKey);
        if (component) {
            if (Array.isArray(component)) {
                const values = await Promise.all(component.map(c => {
                    const componentModel = (0, components_1.getComponentModel)(model, componentKey, c);
                    return populateDoc(componentModel, ref, c, componentModel.defaultPopulate, transaction);
                }));
                _.set(newData, componentKey, values);
            }
            else {
                const componentModel = (0, components_1.getComponentModel)(model, componentKey, component);
                const value = await populateDoc(componentModel, ref, component, componentModel.defaultPopulate, transaction);
                _.set(newData, componentKey, value);
            }
        }
    }));
    await Promise.all(promises);
    // TODO: Better type safety
    return newData;
}
exports.populateDoc = populateDoc;
