import { DocumentReference, Transaction as FirestoreTransaction, Firestore } from '@google-cloud/firestore';
import { DeepReference } from './deep-reference';
import { ReadRepository } from '../utils/read-repository';
import type { Queryable, QuerySnapshot } from './collection';
import { Reference, SetOpts, Snapshot } from './reference';
import { MorphReference } from './morph-reference';
import type { GetOpts, Transaction } from './transaction';
export declare class ReadWriteTransaction implements Transaction {
    readonly firestore: Firestore;
    readonly nativeTransaction: FirestoreTransaction;
    private readonly logStats;
    private readonly attempt;
    private readonly writes;
    private readonly nativeWrites;
    private readonly timestamp;
    private readonly atomicReads;
    private readonly nonAtomicReads;
    private readonly ensureFlatCollections;
    constructor(firestore: Firestore, nativeTransaction: FirestoreTransaction, logStats: boolean, attempt: number);
    getAtomic<T extends object>(ref: Reference<T>, opts?: GetOpts): Promise<Snapshot<T>>;
    getAtomic<T extends object>(refs: Reference<T>[], opts?: GetOpts): Promise<Snapshot<T>[]>;
    getAtomic<T extends object>(query: Queryable<T>): Promise<QuerySnapshot<T>>;
    getNonAtomic<T extends object>(ref: Reference<T>, opts?: GetOpts): Promise<Snapshot<T>>;
    getNonAtomic<T extends object>(refs: Reference<T>[], opts?: GetOpts): Promise<Snapshot<T>[]>;
    getNonAtomic<T extends object>(query: Queryable<T>): Promise<QuerySnapshot<T>>;
    /**
     * @private
     * @deprecated For internal connector use only
     */
    commit(): Promise<void>;
    create<T extends object>(ref: Reference<T>, data: T, opts?: SetOpts): Promise<T>;
    create<T extends object>(ref: Reference<T>, data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    update<T extends object>(ref: Reference<T>, data: T, opts?: SetOpts): Promise<T>;
    update<T extends object>(ref: Reference<T>, data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    delete<T extends object>(ref: Reference<T>, opts?: SetOpts): Promise<void>;
    addNativeWrite(cb: (transaction: FirestoreTransaction) => void): void;
    /**
     * Merges a create, update, or delete operation into pending writes for a given
     * reference in this transaction, without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    mergeWriteInternal<T extends object>(ref: Reference<T>, data: Partial<T> | undefined, editMode: 'create' | 'update'): void;
}
interface RefInfo {
    docRef?: DocumentReference<any>;
    deepRef?: DeepReference<any>;
    morphRef?: MorphReference<any>;
}
export declare function get(refOrQuery: Reference<any> | Queryable<any>, repo: ReadRepository, opts: GetOpts | undefined): Promise<Snapshot<any> | QuerySnapshot<any>>;
export declare function getAll(refs: Reference<any>[], repo: ReadRepository, opts: GetOpts | undefined): Promise<Snapshot<any>[]>;
export declare function getRefInfo(ref: Reference<any>): RefInfo;
export {};
