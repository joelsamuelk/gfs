"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeNormalSnap = exports.NormalReference = void 0;
const reference_1 = require("./reference");
const lifecycle_1 = require("../utils/lifecycle");
/**
 * Acts as a wrapper around a native `DocumentReference`,
 */
class NormalReference extends reference_1.Reference {
    constructor(ref, parent) {
        super();
        this.ref = ref;
        this.parent = parent;
    }
    get id() {
        return this.ref.id;
    }
    get path() {
        return this.ref.path;
    }
    get firestore() {
        return this.ref.firestore;
    }
    async delete(opts) {
        await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data: undefined,
            opts,
            timestamp: new Date(),
        });
    }
    async create(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'create',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    async update(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    /**
     * Performs a `create()`, `update()`, or `delete()` operation without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    async writeInternal(data, editMode) {
        if (data) {
            if (editMode === 'create') {
                await this.ref.create(data);
            }
            else {
                // Firestore does not run the converter on update operations
                const out = this.parent.converter.toFirestore(data);
                await this.ref.update(out);
            }
        }
        else {
            await this.ref.delete();
        }
    }
    async get() {
        return makeNormalSnap(this, await this.ref.get());
    }
    isEqual(other) {
        return (this === other) || ((other instanceof NormalReference)
            && this.ref.isEqual(other.ref));
    }
    /**
     * Allow serialising to JSON.
     */
    toJSON() {
        return this.id;
    }
    /**
     * Returns a value that can be serialised
     * to Firestore.
     */
    toFirestoreValue() {
        return this.ref;
    }
    toString() {
        return this.path;
    }
}
exports.NormalReference = NormalReference;
function makeNormalSnap(ref, snap) {
    const data = snap.data();
    return {
        ref,
        data: () => data,
        id: snap.id,
        exists: snap.exists,
    };
}
exports.makeNormalSnap = makeNormalSnap;
