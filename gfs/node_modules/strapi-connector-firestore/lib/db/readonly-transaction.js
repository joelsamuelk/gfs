"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadOnlyTransaction = void 0;
const read_repository_1 = require("../utils/read-repository");
const virtual_reference_1 = require("./virtual-reference");
const readwrite_transaction_1 = require("./readwrite-transaction");
class ReadOnlyTransaction {
    constructor(firestore, logStats) {
        this.firestore = firestore;
        this.logStats = logStats;
        this.nonAtomicReads = new read_repository_1.ReadRepository({
            getAll: (refs, fieldMask) => firestore.getAll(...refs, { fieldMask }),
            getQuery: query => query.get(),
        });
    }
    /**
     * @deprecated Not supported on ReadonlyTransaction
     */
    get nativeTransaction() {
        throw new Error('nativeTransaction is not supported on ReadonlyTransaction');
    }
    getAtomic() {
        throw new Error('getAtomic() is not supported on ReadOnlyTransaction');
    }
    getNonAtomic(refOrQuery, opts) {
        if (Array.isArray(refOrQuery)) {
            return (0, readwrite_transaction_1.getAll)(refOrQuery, this.nonAtomicReads, opts);
        }
        else {
            return (0, readwrite_transaction_1.get)(refOrQuery, this.nonAtomicReads, opts);
        }
    }
    /**
     * @private
     * @deprecated For internal connector use only
     */
    commit() {
        if (this.logStats && this.nonAtomicReads.readCount) {
            strapi.log.debug(`TRANSACTION (read-only): ${this.nonAtomicReads.readCount} reads.`);
        }
        return Promise.resolve();
    }
    async create(ref, data, opts) {
        if (ref instanceof virtual_reference_1.VirtualReference) {
            return await ref.create(data, opts);
        }
        else {
            throw new Error('create() is not supported on ReadOnlyTransaction');
        }
    }
    async update(ref, data, opts) {
        if (ref instanceof virtual_reference_1.VirtualReference) {
            return await ref.update(data, opts);
        }
        else {
            throw new Error('update() is not supported on ReadOnlyTransaction');
        }
    }
    async delete(ref) {
        if (ref instanceof virtual_reference_1.VirtualReference) {
            return await ref.delete();
        }
        else {
            throw new Error('delete() is not supported on ReadOnlyTransaction');
        }
    }
    /**
     * @deprecated Not supported on ReadOnlyTransaction
     */
    addNativeWrite() {
        throw new Error('Writes are not supported on ReadOnlyTransaction');
    }
    /**
     * Performs write operations only for virtual references. All other write operations
     * are not supported.
     * @private
     * @deprecated For internal connector use only
     */
    mergeWriteInternal(ref, data, editMode) {
        const { docRef } = (0, readwrite_transaction_1.getRefInfo)(ref);
        if (!docRef) {
            ref.writeInternal(data, editMode);
            return;
        }
    }
}
exports.ReadOnlyTransaction = ReadOnlyTransaction;
