"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlatCollection = void 0;
const _ = require("lodash");
const path = require("path");
const convert_where_1 = require("../utils/convert-where");
const deep_reference_1 = require("./deep-reference");
const coerce_to_firestore_1 = require("../coerce/coerce-to-firestore");
const coerce_to_model_1 = require("../coerce/coerce-to-model");
const manual_filter_1 = require("../utils/manual-filter");
class FlatCollection {
    constructor(modelOrOther) {
        this.manualFilters = [];
        this._orderBy = [];
        if (modelOrOther instanceof FlatCollection) {
            // Copy the values
            this.model = modelOrOther.model;
            this.document = modelOrOther.document;
            this.converter = modelOrOther.converter;
            this._ensureDocument = modelOrOther._ensureDocument;
            this.manualFilters = modelOrOther.manualFilters.slice();
            this._orderBy = modelOrOther._orderBy.slice();
            this._limit = modelOrOther._limit;
            this._offset = modelOrOther._offset;
        }
        else {
            this.model = modelOrOther;
            this._ensureDocument = null;
            const { toFirestore = (value) => value, fromFirestore = (value) => value, } = modelOrOther.options.converter;
            this.converter = {
                toFirestore: data => {
                    return _.mapValues(data, (d, path) => {
                        // Remove the document ID component from the field path
                        const { fieldPath } = splitId(path);
                        if (fieldPath === modelOrOther.primaryKey) {
                            return undefined;
                        }
                        // If the field path exists then the value isn't a root model object
                        const obj = fieldPath ? (0, coerce_to_firestore_1.coerceToFirestore)(d) : (0, coerce_to_firestore_1.coerceModelToFirestore)(modelOrOther, d);
                        return toFirestore(obj);
                    });
                },
                fromFirestore: data => {
                    return _.mapValues(data.data(), (d, path) => {
                        const { id, fieldPath } = splitId(path);
                        return (0, coerce_to_model_1.coerceToModel)(modelOrOther, id, fromFirestore(d), fieldPath, {});
                    });
                },
            };
            const docPath = path.posix.join(modelOrOther.collectionName, modelOrOther.options.singleId);
            this.document = modelOrOther.firestore
                .doc(docPath)
                .withConverter(this.converter);
        }
    }
    get path() {
        return this.document.parent.path;
    }
    autoId() {
        return this.document.parent.doc().id;
    }
    doc(id) {
        return new deep_reference_1.DeepReference((id === null || id === void 0 ? void 0 : id.toString()) || this.autoId(), this);
    }
    ;
    /**
     * Ensures that the document containing this flat collection exists.
     * This operation is cached, so that it will happen at most once
     * for the life of the model instance.
     */
    async ensureDocument() {
        // Set and merge with empty object
        // This will ensure that the document exists using
        // as single write operation
        if (!this._ensureDocument) {
            this._ensureDocument = this.document.set({}, { merge: true })
                .catch((err) => {
                this._ensureDocument = null;
                throw err;
            });
        }
        return this._ensureDocument;
    }
    async get(repo) {
        const snap = repo
            ? (await repo.getAll([{ ref: this.document }]))[0]
            : await this.document.get();
        return (0, manual_filter_1.applyManualFilters)({
            model: this.model,
            data: snap.data() || {},
            filters: this.manualFilters,
            orderBy: this._orderBy,
            limit: this._limit,
            offset: this._offset,
        });
    }
    where(clause) {
        const filter = (0, convert_where_1.convertWhere)(this.model, clause, 'manualOnly');
        if (!filter) {
            return this;
        }
        const other = new FlatCollection(this);
        other.manualFilters.push(filter);
        return other;
    }
    orderBy(field, directionStr = 'asc') {
        const other = new FlatCollection(this);
        other._orderBy.push({ field, directionStr });
        return other;
    }
    limit(limit) {
        const other = new FlatCollection(this);
        other._limit = limit;
        return other;
    }
    offset(offset) {
        const other = new FlatCollection(this);
        other._offset = offset;
        return other;
    }
}
exports.FlatCollection = FlatCollection;
function splitId(path) {
    const i = path.indexOf('.');
    if (i === -1) {
        return {
            id: path,
            fieldPath: null,
        };
    }
    else {
        return {
            id: path.slice(0, i),
            fieldPath: path.slice(i + 1),
        };
    }
}
