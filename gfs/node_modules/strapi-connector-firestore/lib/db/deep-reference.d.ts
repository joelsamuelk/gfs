import type { DocumentReference, DocumentSnapshot } from "@google-cloud/firestore";
import type { FlatCollection } from './flat-collection';
import { FlatReferenceShape, Reference, SetOpts, Snapshot } from './reference';
/**
 * References an item in a flattened collection
 * (i.e.) a field within a document.
 */
export declare class DeepReference<T extends object> extends Reference<T> {
    readonly id: string;
    readonly parent: FlatCollection<T>;
    readonly doc: DocumentReference<{
        [id: string]: T;
    }>;
    constructor(id: string, parent: FlatCollection<T>);
    get path(): string;
    get firestore(): FirebaseFirestore.Firestore;
    delete(opts?: SetOpts): Promise<void>;
    create(data: T, opts?: SetOpts): Promise<T>;
    create(data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    update(data: T, opts?: SetOpts): Promise<T>;
    update(data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    /**
     * Performs a `create()`, `update()`, or `delete()` operation without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    writeInternal(data: Partial<T> | undefined, editMode: 'create' | 'update'): Promise<void>;
    get(): Promise<Snapshot<T>>;
    isEqual(other: any): boolean;
    /**
     * Allow serialising to JSON.
     */
    toJSON(): string;
    /**
     * Returns a value that can be serialised
     * to Firestore.
     */
    toFirestoreValue(): FlatReferenceShape<T>;
    toString(): string;
}
export declare function makeDeepSnap<T extends object>(ref: DeepReference<T>, snap: DocumentSnapshot<{
    [id: string]: T;
}>): Snapshot<T>;
export declare function mapToFlattenedDoc<T extends object>({ id }: DeepReference<T>, data: Partial<T> | undefined, merge: boolean): {
    [id: string]: any;
};
