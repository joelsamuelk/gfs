"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToFlattenedDoc = exports.makeDeepSnap = exports.DeepReference = void 0;
const _ = require("lodash");
const reference_1 = require("./reference");
const field_operation_1 = require("./field-operation");
const lifecycle_1 = require("../utils/lifecycle");
/**
 * References an item in a flattened collection
 * (i.e.) a field within a document.
 */
class DeepReference extends reference_1.Reference {
    constructor(id, parent) {
        super();
        this.id = id;
        this.parent = parent;
        if (!id) {
            throw new Error('Document ID must not be empty');
        }
        this.doc = parent.document;
    }
    get path() {
        return `${this.doc.path}/${this.id}`;
    }
    get firestore() {
        return this.doc.firestore;
    }
    async delete(opts) {
        await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data: undefined,
            opts,
            timestamp: new Date(),
        });
    }
    ;
    async create(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'create',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    ;
    async update(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    /**
     * Performs a `create()`, `update()`, or `delete()` operation without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    async writeInternal(data, editMode) {
        const d = mapToFlattenedDoc(this, data, editMode === 'update');
        await this.parent.ensureDocument();
        // TODO: Fail on create if document already exists
        // TODO: Fail on update if document doesn't exist
        // Firestore does not run the converter on update operations
        const out = this.parent.converter.toFirestore(d);
        await this.doc.update(out);
    }
    async get() {
        // Apply a field mask so only the specific entry in flattened document is returned
        // This saves bandwidth from the database
        const [snap] = await this.doc.firestore.getAll(this.doc, { fieldMask: [this.id] });
        return makeDeepSnap(this, snap);
    }
    isEqual(other) {
        return (this === other) ||
            (other instanceof DeepReference
                && this.id === other.id
                && this.doc.isEqual(other.doc));
    }
    /**
     * Allow serialising to JSON.
     */
    toJSON() {
        return this.id;
    }
    /**
     * Returns a value that can be serialised
     * to Firestore.
     */
    toFirestoreValue() {
        return {
            ref: this.doc,
            id: this.id,
        };
    }
    toString() {
        return this.path;
    }
}
exports.DeepReference = DeepReference;
function makeDeepSnap(ref, snap) {
    var _a;
    const data = (_a = snap.data()) === null || _a === void 0 ? void 0 : _a[ref.id];
    return {
        ref,
        data: () => data,
        id: ref.id,
        exists: data !== undefined,
    };
}
exports.makeDeepSnap = makeDeepSnap;
function mapToFlattenedDoc({ id }, data, merge) {
    if ((data !== undefined) && (typeof data !== 'object')) {
        throw new Error(`Invalid data provided to Firestore. It must be an object but it was: ${JSON.stringify(data)}`);
    }
    if (!data) {
        return {
            [id]: field_operation_1.FieldOperation.delete(),
        };
    }
    else {
        if (merge) {
            // Flatten into key-value pairs to merge the fields
            return _.toPairs(data).reduce((d, [path, value]) => {
                d[`${id}.${path}`] = value;
                return d;
            }, {});
        }
        else {
            return { [id]: data };
        }
    }
}
exports.mapToFlattenedDoc = mapToFlattenedDoc;
