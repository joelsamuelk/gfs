"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldOperation = void 0;
const _ = require("lodash");
const firestore_1 = require("@google-cloud/firestore");
const reference_1 = require("./reference");
/**
 * Acts as a wrapper for Firestore's `FieldValue` but allows
 * manual implementation (where Firestore's) API is not public.
 */
class FieldOperation {
    static delete() {
        return new DeleteFieldOperation();
    }
    static increment(n) {
        return new IncrementFieldOperation(n);
    }
    static arrayRemove(...items) {
        return new ArrayRemoveFieldOperation(items);
    }
    static arrayUnion(...items) {
        return new ArrayUnionFieldOperation(items);
    }
    /**
     * Sets the given value and the given path or applies the
     * transform if the value is a transform.
     */
    static apply(data, fieldPath, valueOrOperation) {
        const value = _.get(data, fieldPath);
        const result = valueOrOperation instanceof FieldOperation
            ? valueOrOperation.transform(value)
            : valueOrOperation;
        if (result === undefined) {
            _.unset(data, fieldPath);
        }
        else {
            _.set(data, fieldPath, result);
        }
    }
    /**
     * @deprecated Unsupported operation
     */
    toJSON() {
        throw new Error('Instance of FieldOperation class cannot be serialised to JSON');
    }
}
exports.FieldOperation = FieldOperation;
class DeleteFieldOperation extends FieldOperation {
    constructor() {
        super();
    }
    toFirestoreValue() {
        return firestore_1.FieldValue.delete();
    }
    transform() {
        return undefined;
    }
    coerceWith() {
        return this;
    }
}
class IncrementFieldOperation extends FieldOperation {
    constructor(n) {
        super();
        this.n = n;
    }
    toFirestoreValue() {
        return firestore_1.FieldValue.increment(this.n);
    }
    transform(value) {
        const number = (typeof value === 'number') ? value : 0;
        return number + this.n;
    }
    coerceWith() {
        return this;
    }
}
class ArrayUnionFieldOperation extends FieldOperation {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    toFirestoreValue() {
        return firestore_1.FieldValue.arrayUnion(...this.elements);
    }
    transform(value) {
        // Add any instances that aren't already existing 
        // If the value was not an array then it is overwritten with
        // an empty array
        const arr = (Array.isArray(value) ? value : []);
        const toAdd = this.elements
            .filter(e => !arr.some(value => (0, reference_1.isEqualHandlingRef)(value, e)));
        return arr.concat(toAdd);
    }
    coerceWith(coerceFn) {
        return new ArrayUnionFieldOperation(this.elements.map(coerceFn));
    }
}
class ArrayRemoveFieldOperation extends FieldOperation {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    toFirestoreValue() {
        return firestore_1.FieldValue.arrayRemove(...this.elements);
    }
    transform(value) {
        // Remove all instances from the array 
        // If the value was not an array then it is overwritten with
        // an empty array
        return (Array.isArray(value) ? value : [])
            .filter(value => !this.elements.some(e => (0, reference_1.isEqualHandlingRef)(value, e)));
    }
    coerceWith(coerceFn) {
        return new ArrayRemoveFieldOperation(this.elements.map(coerceFn));
    }
}
