import { DeepReference } from './deep-reference';
import type { Collection } from './collection';
import { MorphReferenceShape, Reference, SetOpts } from './reference';
import { NormalReference } from './normal-reference';
import { VirtualReference } from './virtual-reference';
/**
 * Acts as a wrapper around a `NormalReference` or a `DeepReference`
 * with additional field/filter information for polymorphic references.
 */
export declare class MorphReference<T extends object> extends Reference<T> {
    readonly ref: NormalReference<T> | DeepReference<T> | VirtualReference<T>;
    readonly filter: string | null;
    constructor(ref: NormalReference<T> | DeepReference<T> | VirtualReference<T>, filter: string | null);
    get parent(): Collection<T>;
    get id(): string;
    get path(): string;
    get firestore(): FirebaseFirestore.Firestore;
    delete(opts?: SetOpts): Promise<void>;
    create(data: T, opts?: SetOpts): Promise<T>;
    create(data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    update(data: T, opts?: SetOpts): Promise<T>;
    update(data: Partial<T>, opts?: SetOpts): Promise<Partial<T>>;
    /**
     * Performs a `create()`, `update()`, or `delete()` operation without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    writeInternal(data: Partial<T> | undefined, editMode: 'create' | 'update'): Promise<void>;
    get(): Promise<import("./reference").Snapshot<T>>;
    isEqual(other: any): boolean;
    /**
     * Allow serialising to JSON.
     */
    toJSON(): {
        ref: string;
        kind: string;
        source: string | undefined;
        refId: string;
        field: string | undefined;
    };
    /**
     * Returns a value that can be serialised
     * to Firestore.
     */
    toFirestoreValue(): MorphReferenceShape<T>;
    toString(): string;
}
