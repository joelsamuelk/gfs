"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRefInfo = exports.getAll = exports.get = exports.ReadWriteTransaction = void 0;
const deep_reference_1 = require("./deep-reference");
const read_repository_1 = require("../utils/read-repository");
const reference_1 = require("./reference");
const morph_reference_1 = require("./morph-reference");
const normal_reference_1 = require("./normal-reference");
const lifecycle_1 = require("../utils/lifecycle");
const virtual_reference_1 = require("./virtual-reference");
class ReadWriteTransaction {
    constructor(firestore, nativeTransaction, logStats, attempt) {
        this.firestore = firestore;
        this.nativeTransaction = nativeTransaction;
        this.logStats = logStats;
        this.attempt = attempt;
        this.writes = new Map();
        this.nativeWrites = [];
        this.timestamp = new Date();
        this.ensureFlatCollections = [];
        this.atomicReads = new read_repository_1.ReadRepository({
            getAll: (refs, fieldMask) => this.nativeTransaction.getAll(...refs, { fieldMask }),
            getQuery: query => this.nativeTransaction.get(query),
        });
        this.nonAtomicReads = new read_repository_1.ReadRepository({
            getAll: (refs, fieldMask) => firestore.getAll(...refs, { fieldMask }),
            getQuery: query => query.get(),
        }, this.atomicReads);
    }
    getAtomic(refOrQuery, opts) {
        if (Array.isArray(refOrQuery)) {
            return getAll(refOrQuery, this.atomicReads, opts);
        }
        else {
            return get(refOrQuery, this.atomicReads, opts);
        }
    }
    getNonAtomic(refOrQuery, opts) {
        if (Array.isArray(refOrQuery)) {
            return getAll(refOrQuery, this.nonAtomicReads, opts);
        }
        else {
            return get(refOrQuery, this.nonAtomicReads, opts);
        }
    }
    /**
     * @private
     * @deprecated For internal connector use only
     */
    async commit() {
        if (this.logStats) {
            strapi.log.debug(`TRANSACTION (attempt #${this.attempt}): ${this.writes.size} writes, ${this.atomicReads.readCount + this.nonAtomicReads.readCount} reads (${this.atomicReads.readCount} atomic).`);
        }
        // If we have fetched flat documents then we need to wait to
        // ensure that the document exists so that the update
        // operate will succeed
        await Promise.all(this.ensureFlatCollections);
        for (const op of this.writes.values()) {
            if (op.data === null) {
                this.nativeTransaction.delete(op.ref);
            }
            else {
                if (op.create) {
                    this.nativeTransaction.create(op.ref, op.data);
                }
                else {
                    // Firestore does not run the converter on update operations
                    op.data = op.converter.toFirestore(op.data);
                    this.nativeTransaction.update(op.ref, op.data);
                }
            }
        }
        // Commit any native writes
        for (const cb of this.nativeWrites) {
            cb(this.nativeTransaction);
        }
    }
    async create(ref, data, opts) {
        return (await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'create',
            ref,
            data,
            opts,
            transaction: this,
            timestamp: this.timestamp,
        }));
    }
    async update(ref, data, opts) {
        return (await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref,
            data,
            opts,
            transaction: this,
            timestamp: this.timestamp,
        }));
    }
    async delete(ref, opts) {
        await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref,
            data: undefined,
            opts,
            transaction: this,
            timestamp: this.timestamp,
        });
    }
    addNativeWrite(cb) {
        this.nativeWrites.push(cb);
    }
    /**
     * Merges a create, update, or delete operation into pending writes for a given
     * reference in this transaction, without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    mergeWriteInternal(ref, data, editMode) {
        const { docRef, deepRef } = getRefInfo(ref);
        if (!docRef) {
            ref.writeInternal(data, editMode);
            return;
        }
        const { path } = docRef;
        let op;
        if (this.writes.has(path)) {
            op = this.writes.get(path);
        }
        else {
            op = {
                ref: docRef,
                data: {},
                create: false,
                converter: ref.parent.converter,
            };
            this.writes.set(path, op);
            // If the write is for a flattened collection
            // then pre-emptively start ensuring that the document exists
            if (deepRef) {
                this.ensureFlatCollections.push(deepRef.parent.ensureDocument());
            }
        }
        if (op.data === null) {
            // Deletion overrides all other operations
            return;
        }
        // Don't create documents for flattened collections
        // because we use ensureDocument() and then update()
        op.create = op.create || ((editMode === 'create') && !deepRef) || false;
        if (deepRef) {
            Object.assign(op.data, (0, deep_reference_1.mapToFlattenedDoc)(deepRef, data, true));
        }
        else {
            if (!data) {
                op.data = null;
            }
            else {
                Object.assign(op.data, data);
            }
        }
    }
}
exports.ReadWriteTransaction = ReadWriteTransaction;
async function get(refOrQuery, repo, opts) {
    if (refOrQuery instanceof reference_1.Reference) {
        return (await getAll([refOrQuery], repo, opts))[0];
    }
    else {
        // Queryable
        return await refOrQuery.get(repo);
    }
}
exports.get = get;
async function getAll(refs, repo, opts) {
    const isSingleRequest = opts && opts.isSingleRequest;
    // Collect the masks for each native document
    const getters = new Array(refs.length);
    const docRefs = new Map();
    const virtualGets = [];
    for (let i = 0; i < refs.length; i++) {
        const { docRef, deepRef } = getRefInfo(refs[i]);
        if (!docRef) {
            const index = virtualGets.length;
            const ref = refs[i];
            virtualGets.push(ref.get());
            getters[i] = ({ virtualSnaps }) => virtualSnaps[index];
        }
        else {
            let entry = docRefs.get(docRef.path);
            if (!entry) {
                entry = { ref: docRef, i: docRefs.size };
                docRefs.set(docRef.path, entry);
            }
            if (isSingleRequest && deepRef) {
                if (!entry.fieldMasks) {
                    entry.fieldMasks = [deepRef.id];
                }
                else if (!entry.fieldMasks.includes(deepRef.id)) {
                    entry.fieldMasks.push(deepRef.id);
                }
            }
            getters[i] = ({ ref, results }) => makeSnap(ref, results[entry.i]);
        }
    }
    const refsWithMasks = Array.from(docRefs.values());
    const virtualSnaps = await Promise.all(virtualGets);
    const results = await repo.getAll(refsWithMasks);
    return refs.map((ref, i) => getters[i]({ ref, results, virtualSnaps }));
}
exports.getAll = getAll;
function getRefInfo(ref) {
    if (ref instanceof normal_reference_1.NormalReference) {
        return { docRef: ref.ref };
    }
    if (ref instanceof deep_reference_1.DeepReference) {
        return { docRef: ref.doc, deepRef: ref };
    }
    if (ref instanceof virtual_reference_1.VirtualReference) {
        return {};
    }
    if (ref instanceof morph_reference_1.MorphReference) {
        return {
            ...getRefInfo(ref.ref),
            morphRef: ref,
        };
    }
    throw new Error('Unknown type of reference');
}
exports.getRefInfo = getRefInfo;
function makeSnap(ref, snap) {
    if (ref instanceof normal_reference_1.NormalReference) {
        return (0, normal_reference_1.makeNormalSnap)(ref, snap);
    }
    if (ref instanceof deep_reference_1.DeepReference) {
        return (0, deep_reference_1.makeDeepSnap)(ref, snap);
    }
    if (ref instanceof morph_reference_1.MorphReference) {
        return {
            ...makeSnap(ref, snap),
            ref,
        };
    }
    throw new Error('Unknown type of reference');
}
