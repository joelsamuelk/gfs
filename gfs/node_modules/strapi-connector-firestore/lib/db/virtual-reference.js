"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeVirtualSnap = exports.VirtualReference = void 0;
const reference_1 = require("./reference");
const lifecycle_1 = require("../utils/lifecycle");
const status_error_1 = require("../utils/status-error");
const field_operation_1 = require("./field-operation");
/**
 * References an item in a virtual collection.
 */
class VirtualReference extends reference_1.Reference {
    constructor(id, parent) {
        super();
        this.id = id;
        this.parent = parent;
        if (!id) {
            throw new Error('Document ID must not be empty');
        }
    }
    get path() {
        return `${this.parent.path}/${this.id}`;
    }
    get firestore() {
        return this.parent.model.firestore;
    }
    async delete(opts) {
        await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data: undefined,
            opts,
            timestamp: new Date(),
        });
    }
    ;
    async create(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'create',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    ;
    async update(data, opts) {
        return await (0, lifecycle_1.runUpdateLifecycle)({
            editMode: 'update',
            ref: this,
            data,
            opts,
            timestamp: new Date(),
        });
    }
    /**
     * Performs a `create()`, `update()`, or `delete()` operation without any coercion or lifecycles.
     * @private
     * @deprecated For internal connector use only
     */
    async writeInternal(data, editMode) {
        const virtualData = await this.parent.getData();
        if (data === undefined) {
            delete virtualData[this.id];
        }
        else {
            const existingData = virtualData[this.id];
            if (editMode === 'create') {
                if (existingData !== undefined) {
                    throw new status_error_1.StatusError(`Cannot create a new document that already exists (document: ${this.path})`, 400);
                }
            }
            else {
                if (existingData === undefined) {
                    throw new status_error_1.StatusError(`Cannot update a document that does not exist (document: ${this.path})`, 400);
                }
            }
            // Don't coerce back to native Firestore values because we don't need to
            // The data has already been coerced to the model schema
            const newData = virtualData[this.id] = (existingData || {});
            for (const key of Object.keys(data)) {
                // TODO: Manually handle FieldOperation instances deeper in the data
                field_operation_1.FieldOperation.apply(newData, key, data[key]);
            }
            await this.parent.updateData();
        }
    }
    async get() {
        const virtualData = await this.parent.getData();
        const data = virtualData[this.id];
        const converted = data ? this.parent.converter.fromFirestore(data) : undefined;
        return makeVirtualSnap(this, converted);
    }
    isEqual(other) {
        return (this === other) ||
            (other instanceof VirtualReference
                && this.id === other.id);
    }
    /**
     * Allow serialising to JSON.
     */
    toJSON() {
        return this.id;
    }
    /**
     * Returns a value that can be serialised
     * to Firestore.
     */
    toFirestoreValue() {
        // If other collections reference this virtual collection, then it looks like a normal reference.
        return this.parent.model.firestore.collection(this.parent.path).doc(this.id);
    }
    toString() {
        return this.path;
    }
}
exports.VirtualReference = VirtualReference;
function makeVirtualSnap(ref, data) {
    return {
        ref,
        data: () => data,
        id: ref.id,
        exists: data !== undefined,
    };
}
exports.makeVirtualSnap = makeVirtualSnap;
