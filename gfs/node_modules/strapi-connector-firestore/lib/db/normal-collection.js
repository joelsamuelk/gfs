"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NormalCollection = void 0;
const convert_where_1 = require("../utils/convert-where");
const coerce_to_firestore_1 = require("../coerce/coerce-to-firestore");
const coerce_to_model_1 = require("../coerce/coerce-to-model");
const normal_reference_1 = require("./normal-reference");
const query_error_1 = require("./query-error");
class NormalCollection {
    constructor(modelOrOther) {
        if (modelOrOther instanceof NormalCollection) {
            this.model = modelOrOther.model;
            this.collection = modelOrOther.collection;
            this.converter = modelOrOther.converter;
            this.allowNonNativeQueries = modelOrOther.allowNonNativeQueries;
            this.maxQuerySize = modelOrOther.maxQuerySize;
            this.query = modelOrOther.query;
            this.manualFilters = modelOrOther.manualFilters.slice();
            this._limit = modelOrOther._limit;
            this._offset = modelOrOther._offset;
        }
        else {
            this.model = modelOrOther;
            const { toFirestore = (value) => value, fromFirestore = (value) => value, } = modelOrOther.options.converter;
            this.converter = {
                toFirestore: data => {
                    const d = (0, coerce_to_firestore_1.coerceModelToFirestore)(modelOrOther, data);
                    return toFirestore(d);
                },
                fromFirestore: snap => {
                    const d = fromFirestore(snap.data());
                    return (0, coerce_to_model_1.coerceToModel)(modelOrOther, snap.id, d, null, {});
                },
            };
            this.collection = modelOrOther.firestore
                .collection(modelOrOther.collectionName)
                .withConverter(this.converter);
            this.query = this.collection;
            this.allowNonNativeQueries = modelOrOther.options.allowNonNativeQueries;
            this.maxQuerySize = modelOrOther.options.maxQuerySize;
            this.manualFilters = [];
            if (this.maxQuerySize < 0) {
                throw new Error("maxQuerySize cannot be less than zero");
            }
        }
    }
    get path() {
        return this.collection.path;
    }
    autoId() {
        return this.collection.doc().id;
    }
    doc(id) {
        const doc = id ? this.collection.doc(id.toString()) : this.collection.doc();
        return new normal_reference_1.NormalReference(doc, this);
    }
    warnQueryLimit(limit) {
        const msg = `The query limit of "${limit}" has been capped to "${this.maxQuerySize}".` +
            'Adjust the strapi-connector-firestore \`maxQuerySize\` configuration option ' +
            'if this is not the desired behaviour.';
        if (limit === 'unlimited') {
            // Log at debug level if no limit was set
            strapi.log.debug(msg);
        }
        else {
            // Log at warning level if a limit was explicitly
            // set beyond the maximum limit
            strapi.log.warn(msg);
        }
    }
    async get(trans) {
        try {
            // Ensure the maximum limit is set if no limit has been set yet
            let q = this;
            if (this.maxQuerySize && (this._limit === undefined)) {
                // Log a warning when the limit is applied where no limit was requested
                this.warnQueryLimit('unlimited');
                q = q.limit(this.maxQuerySize);
            }
            const docs = q.manualFilters.length
                ? await queryWithManualFilters(q.query, q.manualFilters, q._limit || 0, q._offset || 0, this.maxQuerySize, trans)
                : await (trans ? trans.getQuery(q.query) : q.query.get()).then(snap => snap.docs);
            return {
                empty: docs.length === 0,
                docs: docs.map(s => {
                    const ref = this.doc(s.id);
                    return (0, normal_reference_1.makeNormalSnap)(ref, s);
                }),
            };
        }
        catch (err) {
            throw new query_error_1.QueryError(err, this.query);
        }
    }
    where(clause) {
        const filter = (0, convert_where_1.convertWhere)(this.model, clause, this.allowNonNativeQueries ? 'preferNative' : 'nativeOnly');
        if (!filter) {
            return this;
        }
        const other = new NormalCollection(this);
        if (typeof filter === 'function') {
            other.manualFilters.push(filter);
        }
        else {
            // Convert the value for Firestore-native query
            const value = (0, coerce_to_firestore_1.coerceToFirestore)(filter.value);
            other.query = this.query.where(filter.field, filter.operator, value);
        }
        return other;
    }
    orderBy(field, directionStr = 'asc') {
        const other = new NormalCollection(this);
        other.query = this.query.orderBy(field, directionStr);
        return other;
    }
    limit(limit) {
        if (this.maxQuerySize && (this.maxQuerySize < limit)) {
            // Log a warning when a limit is explicitly requested larger
            // than than the configured limit
            this.warnQueryLimit(limit);
            limit = this.maxQuerySize;
        }
        const other = new NormalCollection(this);
        other.query = this.query.limit(limit);
        other._limit = limit;
        return other;
    }
    offset(offset) {
        const other = new NormalCollection(this);
        other.query = this.query.offset(offset);
        other._offset = offset;
        return other;
    }
}
exports.NormalCollection = NormalCollection;
async function* queryChunked(query, chunkSize, maxQuerySize, transaction) {
    let cursor;
    let totalReads = 0;
    while (true) {
        if (maxQuerySize) {
            chunkSize = Math.max(chunkSize, maxQuerySize - totalReads);
        }
        if (chunkSize === 0) {
            return;
        }
        let q = query.limit(chunkSize);
        if (cursor) {
            // WARNING:
            // Usage of a cursor implicitly applies field ordering by document ID
            // and this can cause queries to fail
            // E.g. inequality filters require the first sort field to be the same
            // field as the inequality filter (see issue #29)
            // This scenario only manifests when manual queries are used
            q = q.startAfter(cursor);
        }
        const { docs } = await (transaction ? transaction.getQuery(q) : q.get());
        cursor = docs[docs.length - 1];
        totalReads += docs.length;
        for (const d of docs) {
            yield d;
        }
        if (docs.length < chunkSize) {
            return;
        }
    }
}
async function queryWithManualFilters(query, filters, limit, offset, maxQuerySize, transaction) {
    // Use a chunk size of 10 for the native query
    // E.g. if we only want 1 result, we will still query
    // ten at a time to improve performance for larger queries
    // But it will increase read usage (at most 9 reads will be unused)
    const chunkSize = Math.max(10, limit);
    // Improve performance by performing some native offset
    const q = query.offset(offset);
    const docs = [];
    for await (const doc of queryChunked(q, chunkSize, maxQuerySize, transaction)) {
        if (filters.every(op => op(doc))) {
            if (offset) {
                offset--;
            }
            else {
                docs.push(doc);
                if (docs.length >= limit) {
                    break;
                }
            }
        }
    }
    return docs;
}
